esta app va sobre los pipes pero también usa componentes de otra librería así aprendo a implementarlos. 

Un pipe una forma de transformar la información del html

primeNg es un conjunto de componentes, como angular material, lo instalas y lo pones y ya está y tu lo personalizas, cuando trabajas con estos paquetes de componentes funcionas importando modulos, ya lo veremos

Recuerda que los pipes transforman la informanción de manera visual, es decir al usarlos tus datos no se ven afectados de ninguna manera solo cambian su aspecto pero tus datos siguen ahí comoditos, hay bastantes si quieres saber te vas a su documentación a mi solo me parece interesante el que convierte de singular a plural una palabra segun el valor de una variable o el de femenino y masculino

Para cargar primeNg además de instalarlo en npm tienes que ir a angular.json y en styles pegas las lineas que te da primeng, imagino que material funciona igual

Esto lo voy a apuntar porque me parece buena práctica, en lugar de estar importando cada modulo de primeng en app module hace un modulo aparte, los importa allí y los exporta, luego este modulo se importa en app module y se te queda todo más ordenado y si añades añades en primeng.module

RECUERDA revisa siempre bien los modulos y las importaciones la mitad de veces que se rompe algo es por eso 

ANIMACIONES EN ANGULAR, no sabía que para las animaciones hubiera que hacer algo concreto pero bueno, al menos con primeNg y otros componentes con animaciones necesitas BrowserAnimationsModule que segun la documentación es el que permite las animaciones, esto se importa en app.module 
Vamos que si intentas usar una animación y se rompe mires eso

PIPE PERSONALIZADO: no he apuntado nada de los pipes porque son simples, vas a la documentación y está bien explicado. PERO podemos crear nosotros un pipe personalizado, y esto es util porque luego podemos crear nosotros para que se vea como queremos

Para crear un pipe como todo en angular lo que hacemos es usar una clase y luego ponerle el decorador @Pipe({})

En esas llaves le vas pasando argumentos. 
Name dice el nombre con el que te vas a referir a el.
Todos los pipes tienen que implementar el metodo pipetransform. 

Eso nos obliga a tener un metodo transform en esa clase que entiendo es el metodo que ejecuta el pipe para transformar la información
  transform( value:string ):string {
    return value.toUpperCase()
  }
yasta, luego en el html pones {{ 'palabra'|mayusculas}} y te ejecuta la función. Para pasar a mayúsculas es una chorrada pero con esto puedes hacerlo todo lo complejo que quieras y llamarlo de una manera cómoda, además no altera el contenido original

Crear PIPES el comando es casi como el resto: ng g pipe (o p) y localización/nombre

-----------------------------------HEROES APP--------------------
Aquí es donde habla de rutas hijas, ponte las pilas que casi siempre vas a usarlas, también tenemos Angularmaterial y lazyload que optimiza el rendimiento

el lazyload se puede hacer gracias a trabajar con modulos, es decir si alguien no está autorizado no tiene sentido cargar los modulos de dentro de la app

RUTAS HIJAS: funciona parecido a las rutas normales usan routingmodule un array que dice: ruta: 'home' component: homecomponent. 

Primero tienes que crear un modulo en la carpeta que quieres que tenga hijas, es decir si tienes una carpeta app -> auth -> pages
Auth tendrá su modulo para componentes y su modulo para rutas, es decir le dirías: ng g m auth/authRouting

y te genera ahí el modulo, es un modulo normal
okay lo voy a pegar porque esto es algo que tendré que hacer mucho

const routes: Routes = [
  {
    path:'',
    component: homeComponent,
    children: [
      {
        path: 'login',
        component: LoginComponent
      },
      {
        path: 'registro',
        component: RegisterComponent
      },
      {
        path: '**',
        redirectTo: 'login'
      }
    ]
  }
]

@NgModule({
  declarations: [],
  imports: [
    RouterModule.forChild(routes)
  ],
  exports:[
    RouterModule
  ]
})
Ya ves que es normal pero en lugar de tener un objeto para cada ruta general tienes un objeto general con la propiedad children que ya sí que son las rutas en sí, luego en imports no usas forroot, de eso solo hay uno en toda la aplicación, usas for child. 

Tras eso te vas al auth module porque lo tienes que importar allí primero
Luego te vas al app-routingmodule y ahí le tienes que decir oye si alguien navega a esta ruta cargas este modulo, así si no entrar a auth no lo carga y más rendimiento, esto se hace en el array de routes, le añades un objeto tal que así: 
  {
    path:'auth',
    loadChildren: () => import('./auth/auth.module').then(m => m.AuthModule)
  },
Lo que le estás diciendo es cuando alguien entre al path carga este children, usa una función porque primero tiene que importar el modulo eso lo mismo tarda entonces va el then que le dice que cuando esté en memoria entonces el modulo que regresa es el authmodule. 

IMPORTANTE: TIENES QUE CARGAR EL AUTHMODULE NO EL AUTHROUTINGMODULE

Y A PARTIR DE ESA RUTA las rutas del hijo ya van relativas porque primero pasas por el auth, ese te carga su hijo, el hijo tiene sus rutas que se construyen a partir de auth. 

  importante decir que al html de router-outlet no hay que hacerle nada, sencillamente te lo renderiza ahí. 

Esto ya son rutas hijas PERO otras veces esto se refiere a cuando estás en un componente y ese componente a su vez tiene las rutas hijas, es decir, cuando entras a heroes vas a home y ahí deberías tener otro router-outlet y dentro de el se renderizarían estas rutas hijas del mismo modo que en las rutas normales tienes el app.html y las rutas se renderizan en él 

Esto se hace tan fácil como en las rutas, antes de los childrens y después del path, ponerle component: y un componente, por ejemplo home, luego en el html de ese home pones un router-outlet
entonces las rutas hijas lo que hacen es renderizarte el home y ese home ya te renderiza la subruta que toque. 

Es decir, al entrar a heroe se renderiza home y todas las demás hijas se renderizan ahí, esto va bien por ejemplo si quieres un encabezado o una barra de opciones fija en todas las rutas de x sección pues la home lo tiene y el resto se renderiza en su parte. 
También para aplicar estilos concretos a una sección de la aplicación

ANGULAR MATERIAL: funciona exactamente igual que primeng, cogemos el componente que queremos usar vamos a su documentación, lo importamos en nuestro materialmodule, lo exportamos para que otras paginas tengan acceso y lo suamos en el html, luego ya jugamos con javascript el componente y la documentación hasta que salga lo que queremos

Recuerda siempre importar el modulo de material en el modulo en que quieras usar esos componentes

MAT ICON: Importante que si quieres usar un icon de material puedes ver los nombres aqui: https://fonts.google.com/icons?selected=Material+Icons:bookmark&icon.query=menu
y que para que se vea el icono el nombre va entre tag de apertura y de cierre: <mat-icon>menu</mat-icon>

LEVANTAR BBDD: esto es por si se me olvida mañana, vas en la consola a herores server y usas json-server --watch db.json

Va a empezar con cosas crud recuerda que para peticiones y demás lo suyo es hacerlo desde un service